package com.auroali.sanguinisluxuria.datagen.builders;

import com.auroali.sanguinisluxuria.common.conversions.ConversionType;
import com.auroali.sanguinisluxuria.common.conversions.EntityConversionCondition;
import com.auroali.sanguinisluxuria.common.conversions.EntityConversionTransformer;
import com.auroali.sanguinisluxuria.common.registry.BLRegistries;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.minecraft.entity.EntityType;
import net.minecraft.registry.Registries;
import net.minecraft.util.Identifier;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public class ConversionJsonBuilder {
    final EntityType<?> from;
    final EntityType<?> to;
    ConversionType type;
    final List<EntityConversionTransformer> transformers;
    final List<EntityConversionCondition> conditions;

    protected ConversionJsonBuilder(EntityType<?> from, EntityType<?> to) {
        this.from = from;
        this.to = to;
        this.transformers = new ArrayList<>();
        this.conditions = new ArrayList<>();
    }

    /**
     * Creates a new ConversionData json builder
     *
     * @param from the entity this conversion applies to
     * @param to   the entity to convert to
     * @return the new builder
     */
    public static ConversionJsonBuilder create(EntityType<?> from, EntityType<?> to) {
        return new ConversionJsonBuilder(from, to);
    }

    /**
     * Shortcut for creating a conversion builder for conversion types
     * that don't spawn a new entity
     * <br> Equivalent to {@link com.auroali.sanguinisluxuria.datagen.builders.ConversionJsonBuilder#ConversionJsonBuilder(EntityType, EntityType)}
     * with the <code>from</code> parameter passed to both arguments
     *
     * @param from the entity this conversion applies to
     * @return the new builder
     */
    public static ConversionJsonBuilder create(EntityType<?> from) {
        return create(from, from);
    }

    /**
     * Specifies the ConversionType to use
     *
     * @param type the type to use
     * @return this builder, for chaining
     */
    public ConversionJsonBuilder type(ConversionType type) {
        this.type = type;
        return this;
    }

    /**
     * Adds a condition to the builder
     *
     * @param condition the condition to add
     * @return this builder, for chaining
     */
    public ConversionJsonBuilder condition(EntityConversionCondition condition) {
        this.conditions.add(condition);
        return this;
    }

    protected void validate() {
        if (this.from == null || this.to == null)
            throw new IllegalStateException("Must specify both entities for a conversion");
        if (this.type == null)
            throw new IllegalStateException("Conversion Type cannot be null");
    }

    /**
     * Exports the conversion data to the exporter with the given id
     *
     * @param exporter the exporter to use
     * @param id       the id to use
     */
    public void offerTo(Consumer<ConversionJsonBuilder.Provider> exporter, Identifier id) {
        this.validate();
        exporter.accept(new Provider(id, this.from, this.to, this.type, this.transformers, this.conditions));
    }

    /**
     * Exports the conversion data to the exporter with an autogenerated id.
     * <br> The id is in the format {@code namespace:[from_namespace]_[from_path]_to_[to_namespace]_[to_path]}
     *
     * @param exporter  the exporter to use
     * @param namespace the namespace to use
     */
    public void offerTo(Consumer<ConversionJsonBuilder.Provider> exporter, String namespace) {
        this.offerTo(exporter, this.getIdFromEntities(namespace));
    }

    protected Identifier getIdFromEntities(String namespace) {
        Identifier fromId = Registries.ENTITY_TYPE.getId(this.from);
        Identifier toId = Registries.ENTITY_TYPE.getId(this.to);
        String path = fromId.getNamespace() + "_" + fromId.getPath() + "_to_" + toId.getNamespace() + "_" + toId.getPath();
        return new Identifier(namespace, path);
    }

    public ConversionJsonBuilder transformer(EntityConversionTransformer transformer) {
        this.transformers.add(transformer);
        return this;
    }

    public static class Provider {
        private final Identifier id;
        private final EntityType<?> from;
        private final EntityType<?> to;
        private final ConversionType type;
        private final List<EntityConversionTransformer> transformers;
        private final List<EntityConversionCondition> conditions;

        public Provider(Identifier id, EntityType<?> from, EntityType<?> to, ConversionType type, List<EntityConversionTransformer> transformers, List<EntityConversionCondition> conditions) {
            this.id = id;
            this.from = from;
            this.to = to;
            this.type = type;
            this.transformers = transformers;
            this.conditions = conditions;
        }

        public void serialize(JsonObject object) {
            Identifier fromId = Registries.ENTITY_TYPE.getId(this.from);
            Identifier toId = Registries.ENTITY_TYPE.getId(this.to);
            Identifier typeId = BLRegistries.CONVERSION_TYPES.getId(this.type);

            object.addProperty("entity", fromId.toString());
            object.addProperty("target", toId.toString());

            if (typeId == null)
                throw new IllegalStateException("Could not get type id");

            object.addProperty("type", typeId.toString());

            if (!this.transformers.isEmpty()) {
                JsonArray serializedTransformers = new JsonArray();
                this.transformers.forEach(transformer -> {
                    JsonObject transformerJson = transformer.toJson();
                    transformerJson.addProperty(
                      "type",
                      BLRegistries.CONVERSION_TRANSFORMERS.getId(transformer.getSerializer()).toString()
                    );
                    serializedTransformers.add(transformerJson);
                });
                object.add("transformers", serializedTransformers);
            }

            if (!this.conditions.isEmpty()) {
                JsonArray serializedConditions = new JsonArray();
                this.conditions.forEach(condition -> {
                    JsonObject conditionJson = condition.toJson();
                    conditionJson.addProperty(
                      "type",
                      BLRegistries.CONVERSION_CONDITIONS.getId(condition.getSerializer()).toString()
                    );
                    serializedConditions.add(conditionJson);
                });
                object.add("conditions", serializedConditions);
            }
        }

        public Identifier getId() {
            return this.id;
        }
    }
}
